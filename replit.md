# Overview

This is an artwork services management application that allows clients to request design services and designers to manage and deliver those requests. The application facilitates the workflow of custom artwork creation, including file uploads, status tracking, commenting, and designer assignment. Built as a full-stack web application with a React frontend and Express backend, it uses PostgreSQL for data persistence and Google Cloud Storage for file management.

# User Preferences

Preferred communication style: Simple, everyday language.

# System Architecture

## Technology Stack

**Frontend Framework**: React with TypeScript, using Vite as the build tool and development server. The UI is built with shadcn/ui components (Radix UI primitives) and styled with Tailwind CSS.

**Backend Framework**: Express.js server with TypeScript, running on Node.js. The server handles API routes, session management, and integrates with external services.

**Database**: PostgreSQL accessed through Neon's serverless driver, with Drizzle ORM for schema definition and type-safe queries. The schema is defined in a shared module accessible to both client and server.

**File Storage**: Google Cloud Storage for object/file uploads, integrated through Replit's sidecar authentication system. Includes a custom ACL (Access Control List) system for managing file permissions.

**State Management**: TanStack Query (React Query) for server state management, caching, and data fetching on the client side.

**Routing**: Wouter for client-side routing, providing a lightweight alternative to React Router.

**Session Management**: Express-session with MemoryStore for managing user sessions and authentication state.

## Project Structure

The application follows a monorepo structure with three main directories:

- `client/`: React frontend application with components, pages, and UI utilities
- `server/`: Express backend with API routes, storage layer, and object storage integration
- `shared/`: Shared TypeScript code, primarily the database schema definitions

Path aliases are configured for clean imports:
- `@/`: Maps to `client/src/`
- `@shared/`: Maps to `shared/`
- `@assets/`: Maps to `attached_assets/`

## Database Schema

The database uses four primary tables:

**Users**: Stores user accounts with username/password authentication and role-based access (client, designer, admin roles). Users are identified by UUID primary keys.

**Services**: Catalog of available artwork services with pricing, categories, decoration methods, and active/inactive status.

**Service Requests**: Core entity representing client service orders. Includes status workflow (pending → in-progress → delivered/change-request), assignment to designers, due dates, delivery tracking, and change request notes.

**Service Attachments**: File references linked to service requests via foreign key with cascade deletion. Stores object storage paths and metadata.

**Comments**: Discussion threads on service requests with user attribution and timestamps.

All tables use UUID primary keys generated by PostgreSQL's `gen_random_uuid()` function.

## API Design

RESTful API endpoints follow resource-based conventions:

- `/api/users` - User management (get all, get by role, get by ID)
- `/api/services` - Service catalog operations
- `/api/service-requests` - CRUD operations for service requests
- `/api/service-requests/:id/assign` - Designer assignment
- `/api/service-requests/:id/deliver` - Mark as delivered
- `/api/service-requests/:id/change-request` - Request changes
- `/api/service-requests/:id/attachments` - File attachments
- `/api/service-requests/:id/comments` - Comments
- `/api/objects/*` - Object storage operations (upload, download, access control)

The API uses JSON for request/response bodies and includes error handling with appropriate HTTP status codes.

## Authentication & Authorization

**Session-based Authentication**: Uses express-session middleware with in-memory storage. Sessions track `userId` and `userRole` properties.

**Role-based Access Control**: Five-tier role hierarchy with specific permissions:

1. **Admin**: Super user with full system access
   - Can invite any user role
   - Can activate/deactivate any user
   - Can configure client payment methods
   - Can see all service requests and pricing

2. **Internal Designer**: Second-level internal team member
   - Can invite Internal Designers, Vendors, and Vendor Designers
   - Can assign/reassign jobs to any designer role
   - Can see all service requests (no pricing visibility)

3. **Vendor**: External vendor organization admin
   - Can invite Vendors and Vendor Designers to their structure
   - Can activate/deactivate team members under their vendor structure
   - Has Vendor Profile with pricing agreements and SLAs
   - Can see all service requests (no pricing visibility)

4. **Vendor Designer**: Designer working for a specific vendor
   - Linked to parent vendor via `vendorId` field
   - Can assign to other Vendor Designers
   - Can see all service requests (no pricing visibility)

5. **Client**: Service requesters
   - Auto-created on first service request submission
   - Can only see their own requests
   - Can see pricing information
   - Three payment options: Pay-as-you-go, Monthly Payment, Deduct from Tri-POD Royalties

**Pricing Visibility**: Only Clients and Admins can see pricing references.

**Object-level ACL**: Custom access control system for files in Google Cloud Storage. Each object has an ACL policy stored in metadata defining:
- Owner (user ID)
- Visibility (public/private)
- Group-based rules with read/write permissions

## User Management

**User Management Page** (`/users`): Available to Admin, Internal Designer, and Vendor users
- Search and filter users by role
- Invite new users with role-based invitation permissions
- Activate/deactivate users (Admin can toggle any user, Vendor can toggle their team members)
- Configure client payment methods (Admin only)

**Vendor Profile Page** (`/vendor-profile`): Available to Vendor users only
- Company information (name, website, email, phone)
- Team management with activate/deactivate toggles
- Pricing agreements table for all service types
- SLA configuration (days/hours per service type)

**Vendor Profiles Table**: Stores vendor-specific data
- Company information
- Pricing agreements per service type (JSON)
- SLA configuration per service type (JSON)

The ACL system is extensible to support different group types for fine-grained access control.

## File Upload Strategy

**Client-side Direct Upload**: Uses presigned URLs to upload files directly from browser to Google Cloud Storage, avoiding server bandwidth limitations.

**Upload Flow**:
1. Client requests upload URL from backend
2. Backend generates presigned URL with ACL policy
3. Client uploads file directly to Google Cloud Storage
4. Client notifies backend of successful upload
5. Backend creates attachment record in database

**File Components**: Custom `FileUploader` component provides drag-and-drop interface with progress tracking and error handling.

## State Management Pattern

**Server State**: TanStack Query manages all server data fetching, caching, and synchronization. Query keys follow URL pattern (e.g., `["/api/services"]`) for automatic cache invalidation.

**Optimistic Updates**: Mutations use `onSuccess` callbacks to invalidate relevant queries, triggering automatic refetch of updated data.

**Default Query Options**: Configured with infinite stale time and disabled automatic refetching to reduce unnecessary network requests while maintaining explicit cache invalidation on mutations.

## UI Component Architecture

**Design System**: shadcn/ui components provide consistent, accessible UI primitives. Components use Radix UI headless components with custom Tailwind styling.

**Custom Theming**: CSS variables define color palette and typography scales. Supports custom color scheme (blue-lavender, space-cadet, etc.) alongside standard shadcn theme tokens.

**Responsive Design**: Mobile-first approach with responsive breakpoints. Custom `useIsMobile` hook detects viewport size for conditional rendering.

**Layout Pattern**: Common Header component with navigation, with page-specific content rendered through Wouter routing.

## Reports Module

**Role-Based Access**: Reports are visible to Admin, Client, and Vendor roles only (not Internal Designer or Vendor Designer).

**Reports Hub** (`/reports`): Central landing page showing role-specific report cards:
- Admin sees: Services Profit Report
- Client sees: Stripe Billing, Services Consumption (placeholders for future)
- Vendor sees: Vendor Earnings (placeholder for future)

**Services Profit Report** (`/reports/services-profit`): Admin-only comprehensive financial report featuring:
- Summary cards: Total Revenue, Vendor Costs, Net Profit, Profit Margin percentage
- Filters: Vendor dropdown, Service Type, Date From/To
- Search: By Client name, By Job ID
- Data table with columns: Job ID, Client, Service, Status, Assignee, Vendor, Retail Price, Vendor Cost, Discount (placeholder), Profit, Created Date

**Pricing Calculations**:
- Retail Price: Calculated using service pricing tiers and form data (complexity, quantity)
- Vendor Cost: Uses vendor-specific pricingAgreements from vendorProfiles table
- Exception Rules:
  - Admin-created jobs: $0 retail revenue (internal/comped jobs)
  - Internal Designer assignments: $0 vendor cost (no external vendor involved)
  - Vendor Designer assignments: Costs attributed to parent vendor via vendorId field

**Technical Implementation**: Report data computed client-side using existing API endpoints (`/api/service-requests`, `/api/services`, `/api/users`, `/api/vendor-profiles`) for efficiency.

# External Dependencies

## Cloud Services

**Google Cloud Storage**: Primary file storage backend accessed through the Google Cloud Storage Node.js client library. Uses Replit's sidecar service for credential management via external account authentication flow.

**Neon Database**: Serverless PostgreSQL database accessed via HTTP using `@neondatabase/serverless` driver. Connection configured through `DATABASE_URL` environment variable.

## Authentication Infrastructure

**Replit Sidecar**: Local service running at `http://127.0.0.1:1106` providing OAuth token exchange for Google Cloud Platform services. Eliminates need for service account keys in the repository.

## Key Third-party Libraries

**Drizzle ORM**: Type-safe database toolkit with schema-first approach. Uses `drizzle-kit` for schema migrations and `drizzle-zod` for runtime validation.

**Form Management**: React Hook Form with Zod resolvers for type-safe form validation and submission handling.

**Date Utilities**: date-fns for date formatting and manipulation throughout the application.

**File Upload**: Uppy file upload framework with AWS S3 adapter (compatible with Google Cloud Storage). Provides dashboard UI and multi-file upload capabilities.

## Development Tools

**Replit Plugins**: Development environment includes cartographer (code navigation) and dev banner plugins when running in Replit environment, automatically excluded in production builds.

**Build Process**: Vite for frontend bundling, esbuild for backend compilation. Production build outputs to `dist/` directory with static assets in `dist/public/`.

## Environment Configuration

Required environment variables:
- `DATABASE_URL`: PostgreSQL connection string
- `SESSION_SECRET`: Secret key for session signing
- `PUBLIC_OBJECT_SEARCH_PATHS`: Comma-separated paths for public object access (optional)

The application detects Replit environment via `REPL_ID` environment variable to enable platform-specific features.