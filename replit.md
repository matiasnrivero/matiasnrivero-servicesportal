# Overview

This is an artwork services management application that allows clients to request design services and designers to manage and deliver those requests. The application facilitates the workflow of custom artwork creation, including file uploads, status tracking, commenting, and designer assignment. Built as a full-stack web application with a React frontend and Express backend, it uses PostgreSQL for data persistence and Google Cloud Storage for file management.

# User Preferences

Preferred communication style: Simple, everyday language.

# System Architecture

## Technology Stack

**Frontend Framework**: React with TypeScript, using Vite as the build tool and development server. The UI is built with shadcn/ui components (Radix UI primitives) and styled with Tailwind CSS.

**Backend Framework**: Express.js server with TypeScript, running on Node.js. The server handles API routes, session management, and integrates with external services.

**Database**: PostgreSQL accessed through Neon's serverless driver, with Drizzle ORM for schema definition and type-safe queries. The schema is defined in a shared module accessible to both client and server.

**File Storage**: Google Cloud Storage for object/file uploads, integrated through Replit's sidecar authentication system. Includes a custom ACL (Access Control List) system for managing file permissions.

**State Management**: TanStack Query (React Query) for server state management, caching, and data fetching on the client side.

**Routing**: Wouter for client-side routing, providing a lightweight alternative to React Router.

**Session Management**: Express-session with MemoryStore for managing user sessions and authentication state.

## Project Structure

The application follows a monorepo structure with three main directories:

- `client/`: React frontend application with components, pages, and UI utilities
- `server/`: Express backend with API routes, storage layer, and object storage integration
- `shared/`: Shared TypeScript code, primarily the database schema definitions

Path aliases are configured for clean imports:
- `@/`: Maps to `client/src/`
- `@shared/`: Maps to `shared/`
- `@assets/`: Maps to `attached_assets/`

## Database Schema

The database uses four primary tables:

**Users**: Stores user accounts with username/password authentication and role-based access (client, designer, admin roles). Users are identified by UUID primary keys.

**Services**: Catalog of available artwork services with pricing, categories, decoration methods, and active/inactive status.

**Service Requests**: Core entity representing client service orders. Includes status workflow (pending → in-progress → delivered/change-request), assignment to designers, due dates, delivery tracking, and change request notes.

**Service Attachments**: File references linked to service requests via foreign key with cascade deletion. Stores object storage paths and metadata.

**Comments**: Discussion threads on service requests with user attribution and timestamps.

All tables use UUID primary keys generated by PostgreSQL's `gen_random_uuid()` function.

## API Design

RESTful API endpoints follow resource-based conventions:

- `/api/users` - User management (get all, get by role, get by ID)
- `/api/services` - Service catalog operations
- `/api/service-requests` - CRUD operations for service requests
- `/api/service-requests/:id/assign` - Designer assignment
- `/api/service-requests/:id/deliver` - Mark as delivered
- `/api/service-requests/:id/change-request` - Request changes
- `/api/service-requests/:id/attachments` - File attachments
- `/api/service-requests/:id/comments` - Comments
- `/api/objects/*` - Object storage operations (upload, download, access control)

The API uses JSON for request/response bodies and includes error handling with appropriate HTTP status codes.

## Authentication & Authorization

**Session-based Authentication**: Uses express-session middleware with in-memory storage. Sessions track `userId` and `userRole` properties.

**Role-based Access Control**: Three roles supported (client, designer, admin) with different permissions:
- Clients can create requests and view their own requests
- Designers can be assigned requests and update their status
- Admin role exists for future administrative features

**Object-level ACL**: Custom access control system for files in Google Cloud Storage. Each object has an ACL policy stored in metadata defining:
- Owner (user ID)
- Visibility (public/private)
- Group-based rules with read/write permissions

The ACL system is extensible to support different group types for fine-grained access control.

## File Upload Strategy

**Client-side Direct Upload**: Uses presigned URLs to upload files directly from browser to Google Cloud Storage, avoiding server bandwidth limitations.

**Upload Flow**:
1. Client requests upload URL from backend
2. Backend generates presigned URL with ACL policy
3. Client uploads file directly to Google Cloud Storage
4. Client notifies backend of successful upload
5. Backend creates attachment record in database

**File Components**: Custom `FileUploader` component provides drag-and-drop interface with progress tracking and error handling.

## State Management Pattern

**Server State**: TanStack Query manages all server data fetching, caching, and synchronization. Query keys follow URL pattern (e.g., `["/api/services"]`) for automatic cache invalidation.

**Optimistic Updates**: Mutations use `onSuccess` callbacks to invalidate relevant queries, triggering automatic refetch of updated data.

**Default Query Options**: Configured with infinite stale time and disabled automatic refetching to reduce unnecessary network requests while maintaining explicit cache invalidation on mutations.

## UI Component Architecture

**Design System**: shadcn/ui components provide consistent, accessible UI primitives. Components use Radix UI headless components with custom Tailwind styling.

**Custom Theming**: CSS variables define color palette and typography scales. Supports custom color scheme (blue-lavender, space-cadet, etc.) alongside standard shadcn theme tokens.

**Responsive Design**: Mobile-first approach with responsive breakpoints. Custom `useIsMobile` hook detects viewport size for conditional rendering.

**Layout Pattern**: Common Header component with navigation, with page-specific content rendered through Wouter routing.

# External Dependencies

## Cloud Services

**Google Cloud Storage**: Primary file storage backend accessed through the Google Cloud Storage Node.js client library. Uses Replit's sidecar service for credential management via external account authentication flow.

**Neon Database**: Serverless PostgreSQL database accessed via HTTP using `@neondatabase/serverless` driver. Connection configured through `DATABASE_URL` environment variable.

## Authentication Infrastructure

**Replit Sidecar**: Local service running at `http://127.0.0.1:1106` providing OAuth token exchange for Google Cloud Platform services. Eliminates need for service account keys in the repository.

## Key Third-party Libraries

**Drizzle ORM**: Type-safe database toolkit with schema-first approach. Uses `drizzle-kit` for schema migrations and `drizzle-zod` for runtime validation.

**Form Management**: React Hook Form with Zod resolvers for type-safe form validation and submission handling.

**Date Utilities**: date-fns for date formatting and manipulation throughout the application.

**File Upload**: Uppy file upload framework with AWS S3 adapter (compatible with Google Cloud Storage). Provides dashboard UI and multi-file upload capabilities.

## Development Tools

**Replit Plugins**: Development environment includes cartographer (code navigation) and dev banner plugins when running in Replit environment, automatically excluded in production builds.

**Build Process**: Vite for frontend bundling, esbuild for backend compilation. Production build outputs to `dist/` directory with static assets in `dist/public/`.

## Environment Configuration

Required environment variables:
- `DATABASE_URL`: PostgreSQL connection string
- `SESSION_SECRET`: Secret key for session signing
- `PUBLIC_OBJECT_SEARCH_PATHS`: Comma-separated paths for public object access (optional)

The application detects Replit environment via `REPL_ID` environment variable to enable platform-specific features.